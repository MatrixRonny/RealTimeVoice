<html>
<head>
    <title>OpenAI Realtime Voice</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        .voice-text-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .voice-text-box {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .voice-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        textarea[readonly] {
            resize: vertical;
            overflow-y: auto;
            width: 100%;
            height: 150px;
            font-size: 1em;
            padding: 8px;
            box-sizing: border-box;
        }
    </style>
</head>

<body onload="startVoiceChatOverWebRTC()">
    <h1>OpenAI Realtime Voice</h1>
    <p>This example shows how to use OpenAI's Realtime Voice API to stream audio from your microphone and receive audio responses from the model.</p>

    <div class="voice-text-container">
        <div class="voice-text-box">
            <span class="voice-label">User Voice (Text)</span>
            <textarea id="userVoiceText" readonly></textarea>
        </div>
        <div class="voice-text-box">
            <span class="voice-label">AI Voice (Text)</span>
            <textarea id="aiVoiceText" readonly></textarea>
        </div>
    </div>
</body>
</html>

<script>
    async function startVoiceChatOverWebRTC() {
        // Get an ephemeral key from your server - see server code below
        const tokenResponse = await fetch("/get-token");
        const sessionToken = await tokenResponse.text();

        // Create a peer connection
        const pc = new RTCPeerConnection();

        // Set up to play remote audio from the model
        const audioEl = document.createElement("audio");
        audioEl.autoplay = true;
        pc.ontrack = e => audioEl.srcObject = e.streams[0];

        // Add local audio track for microphone input in the browser
        const ms = await navigator.mediaDevices.getUserMedia({
            audio: true
        });
        pc.addTrack(ms.getTracks()[0]);

        // Set up data channel for sending and receiving events
        const dc = pc.createDataChannel("oai-events");
        dc.addEventListener("message", processWebRTCMessage);

        // Start the session using the Session Description Protocol (SDP)
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = "https://api.openai.com/v1/realtime";
        const model = "gpt-4o-realtime-preview-2025-06-03";
        const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
            method: "POST",
            body: offer.sdp,
            headers: {
                Authorization: `Bearer ${sessionToken}`,
                "Content-Type": "application/sdp"
            },
        });

        const answer = {
            type: "answer",
            sdp: await sdpResponse.text(),
        };
        await pc.setRemoteDescription(answer);
    }

    function processWebRTCMessage(event) {
        console.log(event);

        try {
            const dataObject = JSON.parse(event.data);

            // Defensive: fallback to empty string if transcript is missing
            const transcript = dataObject.transcript || '';

            if (dataObject.type === 'response.audio_transcript.done') {
                // Handle agent (assistant) response
                const aiTextArea = document.getElementById("aiVoiceText");
                if (aiTextArea) aiTextArea.value += transcript + "\n";
            }
            else if (dataObject.type === 'conversation.item.input_audio_transcription.completed') {
                // Handle user input transcription
                const userTextArea = document.getElementById("userVoiceText");
                if (userTextArea) userTextArea.value += transcript + "\n";
            }
            else {
                // Ignore other message types
            }
        } catch (err) {
            console.error("Failed to parse message data:", err);
        }
    }
</script>